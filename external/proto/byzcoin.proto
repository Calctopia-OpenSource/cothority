syntax = "proto2";
package byzcoin;
import "skipchain.proto";
import "onet.proto";
import "darc.proto";
import "trie.proto";

option java_package = "ch.epfl.dedis.lib.proto";
option java_outer_classname = "ByzCoinProto";

// GetAllByzCoinIDsRequest is a request to get all the Byzcoin chains from a server.
message GetAllByzCoinIDsRequest {
}

// GetAllByzCoinIDsResponse contains the list of Byzcoin chains known by a server.
message GetAllByzCoinIDsResponse {
  repeated bytes ids = 1;
}

// DataHeader is the data passed to the Skipchain
message DataHeader {
  // TrieRoot is the root of the merkle tree of the colleciton after
  // applying the valid transactions.
  required bytes trieroot = 1;
  // ClientTransactionHash is the sha256 hash of all the transactions in the body
  required bytes clienttransactionhash = 2;
  // StateChangesHash is the sha256 of all the StateChanges generated by the
  // accepted transactions.
  required bytes statechangeshash = 3;
  // Timestamp is a Unix timestamp in nanoseconds.
  required sint64 timestamp = 4;
  // Version is the version of ByzCoin at the creation of the block.
  optional sint32 version = 5;
}

// DataBody is stored in the body of the skipblock, and it's hash is stored
// in the DataHeader.
message DataBody {
  repeated TxResult txresults = 1;
}

// ***
// These are the messages used in the API-calls
// ***

// CreateGenesisBlock asks the cisc-service to set up a new skipchain.
message CreateGenesisBlock {
  // Version of the protocol
  required sint32 version = 1;
  // Roster defines which nodes participate in the skipchain.
  required onet.Roster roster = 2;
  // GenesisDarc defines who is allowed to write to this skipchain.
  required darc.Darc genesisdarc = 3;
  // BlockInterval in int64.
  required sint64 blockinterval = 4;
  // Maximum block size. Zero (or not present in protobuf) means use the default, 4 megs.
  optional sint32 maxblocksize = 5;
  // DarcContracts is the set of contracts that can be parsed as a DARC.
  // At least one contract must be given.
  repeated string darccontractids = 6;
}

// CreateGenesisBlockResponse holds the genesis-block of the new skipchain.
message CreateGenesisBlockResponse {
  // Version of the protocol
  required sint32 version = 1;
  // Skipblock of the created skipchain or empty if there was an error.
  optional skipchain.SkipBlock skipblock = 2;
}

// AddTxRequest requests to apply a new transaction to the ledger.
message AddTxRequest {
  // Version of the protocol
  required sint32 version = 1;
  // SkipchainID is the hash of the first skipblock
  required bytes skipchainid = 2;
  // Transaction to be applied to the kv-store
  required ClientTransaction transaction = 3;
  // How many block-intervals to wait for inclusion -
  // missing value or 0 means return immediately.
  optional sint32 inclusionwait = 4;
  // ProofFrom is used to ask a proof from a given block. If this field
  // is empty, the proof will start from the genesis block. The proof is
  // returned only when InclusionWait is above 0.
  optional bytes prooffrom = 5;
  // Flags can hold additional flags to pass to the endpoint.
  // Current flags supported are:
  // - 1: leader check - don't propagate further
  optional sint32 flags = 6;
}

// AddTxResponse is the reply after an AddTxRequest is finished.
message AddTxResponse {
  // Version of the protocol
  required sint32 version = 1;
  // Error message describes why the transaction failed.
  optional string error = 2;
  // Proof of the block with the transaction.
  optional Proof proof = 3;
}

// GetProof returns the proof that the given key is in the trie.
message GetProof {
  // Version of the protocol
  required sint32 version = 1;
  // Key is the key we want to look up
  required bytes key = 2;
  // ID is any block that is known to us in the skipchain, can be the genesis
  // block or any later block. The proof returned will be starting at this block.
  required bytes id = 3;
  // MustContainBlock when provided informs the server that the proof
  // should include this block.
  optional bytes mustcontainblock = 4;
}

// GetProofResponse can be used together with the Genesis block to proof that
// the returned key/value pair is in the trie.
message GetProofResponse {
  // Version of the protocol
  required sint32 version = 1;
  // Proof contains everything necessary to prove the inclusion
  // of the included key/value pair given a genesis skipblock.
  required Proof proof = 2;
}

// CheckAuthorization returns the list of actions that could be executed if the
// signatures of the given identities are present and valid
message CheckAuthorization {
  // Version of the protocol
  required sint32 version = 1;
  // ByzCoinID where to look up the darc
  required bytes byzcoinid = 2;
  // DarcID that holds the rules
  required bytes darcid = 3;
  // Identities that will sign together
  repeated darc.Identity identities = 4;
}

// CheckAuthorizationResponse returns a list of Actions that the given identities
// can execute in the given darc. The list can be empty, which means that the
// given identities have now authorization in that darc at all.
message CheckAuthorizationResponse {
  repeated string actions = 1;
}

// ChainConfig stores all the configuration information for one skipchain. It
// will be stored under the key [32]byte{} in the tree.
message ChainConfig {
  required sint64 blockinterval = 1;
  required onet.Roster roster = 2;
  required sint32 maxblocksize = 3;
  repeated string darccontractids = 4;
}

// Proof represents everything necessary to verify a given
// key/value pair is stored in a skipchain. The proof is in three parts:
//   1. InclusionProof proves the presence or absence of the key. In case of
//   the key being present, the value is included in the proof.
//   2. Latest is used to verify the Merkle tree root used in the proof is
//   stored in the latest skipblock.
//   3. Links proves that the latest skipblock is part of the skipchain.
//
// This Structure could later be moved to cothority/skipchain.
message Proof {
  // InclusionProof is the deserialized InclusionProof
  required trie.Proof inclusionproof = 1;
  // Providing the latest skipblock to retrieve the Merkle tree root.
  required skipchain.SkipBlock latest = 2;
  // Proving the path to the latest skipblock. The first ForwardLink has an
  // empty-sliced `From` and the genesis-block in `To`, together with the
  // roster of the genesis-block in the `NewRoster`.
  repeated skipchain.ForwardLink links = 3;
}

// Instruction holds only one of Spawn, Invoke, or Delete
message Instruction {
  // InstanceID is either the instance that can spawn a new instance, or the instance
  // that will be invoked or deleted.
  required bytes instanceid = 1;
  // Spawn creates a new instance.
  optional Spawn spawn = 2;
  // Invoke calls a method of an existing instance.
  optional Invoke invoke = 3;
  // Delete removes the given instance.
  optional Delete delete = 4;
  // SignerCounter must be set to a value that is one greater than what
  // was in the last instruction signed by the same signer. Every counter
  // must map to the corresponding element in Signature. The initial
  // counter is 1. Overflow is allowed.
  repeated uint64 signercounter = 5 [packed=true];
  // SignerIdentities are the identities of all the signers.
  repeated darc.Identity signeridentities = 6;
  // Signatures that are verified using the Darc controlling access to
  // the instance.
  repeated bytes signatures = 7;
  // synthetic is a private field indicating that the instruction has been
  // artificially created, which can give it additional rights (see
  // Instruction.usesForbiddenIdentities()).
  // version is a private field that can allow an instruction to be passed
  // around with the context of a block with a specific version.
  // This field must be the last field of the struct, so that the
  // protobuf-library enumerates the fields correctly.
}

// Spawn is called upon an existing instance that will spawn a new instance.
message Spawn {
  // ContractID represents the kind of contract that is being spawned.
  required string contractid = 1;
  // Args holds all data necessary to spawn the new instance.
  repeated Argument args = 2;
}

// Invoke calls a method of an existing instance which will update its internal
// state.
message Invoke {
  // ContractID represents the kind of contract that is being invoked.
  required string contractid = 1;
  // Command is interpreted by the contract.
  required string command = 2;
  // Args holds all data necessary for the successful execution of the command.
  repeated Argument args = 3;
}

// Delete removes the instance. The contract might enforce conditions that
// must be true before a Delete is executed.
message Delete {
  // ContractID represents the kind of contract that is being deleted.
  required string contractid = 1;
  // Args holds all data necessary to delete the instance.
  repeated Argument args = 2;
}

// Argument is a name/value pair that will be passed to the contract.
message Argument {
  // Name can be any name recognized by the contract.
  required string name = 1;
  // Value must be binary marshalled
  required bytes value = 2;
}

// ClientTransaction is a slice of Instructions that will be applied in order.
// If any of the instructions fails, none of them will be applied.
// InstructionsHash must be the hash of the concatenation of all the
// instruction hashes (see the Hash method in Instruction), this hash is what
// every instruction must sign for the transaction to be valid.
message ClientTransaction {
  repeated Instruction instructions = 1;
}

// TxResult holds a transaction and the result of running it.
message TxResult {
  required ClientTransaction clienttransaction = 1;
  required bool accepted = 2;
}

// StateChange is one new state that will be applied to the collection.
message StateChange {
  // StateAction can be any of Create, Update, Remove
  required sint32 stateaction = 1;
  // InstanceID of the state to change
  required bytes instanceid = 2;
  // ContractID points to the contract that can interpret the value
  required string contractid = 3;
  // Value is the data needed by the contract
  required bytes value = 4;
  // DarcID is the Darc controlling access to this key.
  required bytes darcid = 5;
  // Version is the monotonically increasing version of the instance
  required uint64 version = 6;
}

// Coin is a generic structure holding any type of coin. Coins are defined
// by a genesis coin instance that is unique for each type of coin.
message Coin {
  // Name points to the genesis instance of that coin.
  required bytes name = 1;
  // Value is the total number of coins of that type.
  required uint64 value = 2;
}

// StreamingRequest is a request asking the service to start streaming blocks
// on the chain specified by ID.
message StreamingRequest {
  required bytes id = 1;
}

// StreamingResponse is the reply (block) that is streamed back to the client
message StreamingResponse {
  optional skipchain.SkipBlock block = 1;
}

// PaginateRequest is a request to get NumPages times the consecutive list of
// PageSize blocks.
message PaginateRequest {
  // The first block to fetch
  required bytes startid = 1;
  // Determines the length of the Blocks attribute in the PaginateResponse.
  // The list contains PageSize consecutive blocks
  required uint64 pagesize = 2;
  // The number of (asynchrounous) requests the service will return to the
  // client. Requests are send in a consecutive order wrt their list of blocks
  required uint64 numpages = 3;
  // If true then blocks are consecutive in the reverse order, ie. following
  // backward links.
  required bool backward = 4;
}

// PaginateResponse is a reponse from a PaginateRequest.
message PaginateResponse {
  // A list of consecutive blocks
  repeated skipchain.SkipBlock blocks = 1;
  // The page number index: relevant if the clients asked for more than one
  // asynchrounous reply from the service.
  required uint64 pagenumber = 2;
  // Tells if the result contains consecutive blocks in a reversed order.
  required bool backward = 3;
  // Used to tell the client if an error occured. Any error code not equal to
  // 0 means that something special happened.
  required uint64 errorcode = 4;
  // A list of error messages in case something special happened.
  repeated string errortext = 5;
}

// DownloadState requests the current global state of that node.
// If it is the first call to the service, then Reset
// must be true, else an error will be returned, or old data
// might be used.
message DownloadState {
  // ByzCoinID of the state to download
  required bytes byzcoinid = 1;
  // Nonce is 0 for a new download, else it must be
  // equal to the nonce returned in DownloadStateResponse.
  // In case Nonce is non-zero, but doesn't correspond
  // to the current session, an error is returned,
  // as only one download-session can be active at
  // any given moment.
  required uint64 nonce = 2;
  // Length of the statechanges to download
  required sint32 length = 3;
}

// DownloadStateResponse is returned by the service. If there are no
// Instances left, then the length of Instances is 0.
message DownloadStateResponse {
  // KeyValues holds a copy of a slice of DBKeyValues
  // directly from bboltdb
  repeated DBKeyValue keyvalues = 1;
  // Nonce to be used for the download. The Nonce
  // is generated by the server, and will be set
  // for every subsequent reply, too.
  required uint64 nonce = 2;
  // Total key/value pairs.
  optional sint32 total = 3;
}

// DBKeyValue represents one element in bboltdb
message DBKeyValue {
  required bytes key = 1;
  required bytes value = 2;
}

// StateChangeBody represents the body part of a state change, which is the
// part that needs to be serialised and stored in a merkle tree.
message StateChangeBody {
  required sint32 stateaction = 1;
  required string contractid = 2;
  required bytes value = 3;
  required uint64 version = 4;
  required bytes darcid = 5;
}

// GetSignerCounters is a request to get the latest version for the specified
// identity.
message GetSignerCounters {
  repeated string signerids = 1;
  required bytes skipchainid = 2;
}

// GetSignerCountersResponse holds the latest version for the identity in the
// request.
message GetSignerCountersResponse {
  repeated uint64 counters = 1 [packed=true];
  // Index contains the trie index where the counters
  // have been extracted so clients can use it to
  // make sure the counters are up-to-date.
  optional uint64 index = 2;
}

// GetInstanceVersion is a request asking the service to fetch
// the version of the given instance
message GetInstanceVersion {
  required bytes skipchainid = 1;
  required bytes instanceid = 2;
  required uint64 version = 3;
}

// GetLastInstanceVersion is request asking for the last version
// of a given instance
message GetLastInstanceVersion {
  required bytes skipchainid = 1;
  required bytes instanceid = 2;
}

// GetInstanceVersionResponse is the response for both
// GetInstanceVersion and GetLastInstanceVersion. It contains
// the state change if it exists and the block index where
// it has been applied
message GetInstanceVersionResponse {
  required StateChange statechange = 1;
  required sint32 blockindex = 2;
}

// GetAllInstanceVersion is a request asking for the list of
// state changes of a given instance
message GetAllInstanceVersion {
  required bytes skipchainid = 1;
  required bytes instanceid = 2;
}

// GetAllInstanceVersionResponse is the response that contains
// the list of state changes of a instance
message GetAllInstanceVersionResponse {
  repeated GetInstanceVersionResponse statechanges = 1;
}

// CheckStateChangeValidity is a request to get the list
// of state changes belonging to the same block as the
// targeted one to compute the hash
message CheckStateChangeValidity {
  required bytes skipchainid = 1;
  required bytes instanceid = 2;
  required uint64 version = 3;
}

// CheckStateChangeValidityResponse is the response with
// the list of state changes so that the hash can be
// compared against the one in the block
message CheckStateChangeValidityResponse {
  repeated StateChange statechanges = 1;
  required bytes blockid = 2;
}

// ResolveInstanceID is the request for resolving the instance ID based on the
// Darc ID and the name.
message ResolveInstanceID {
  required bytes skipchainid = 1;
  required bytes darcid = 2;
  required string name = 3;
}

// ResolvedInstanceID is the result of the instance ID resolution.
message ResolvedInstanceID {
  required bytes instanceid = 1;
}

// DebugRequest returns the list of all byzcoins if byzcoinid is empty, else it returns
// a dump of all instances if byzcoinid is given and exists.
message DebugRequest {
  optional bytes byzcoinid = 1;
}

// DebugResponse is returned from the server. Either Byzcoins is returned and holds a
// list of all byzcoin-instances, together with the genesis block and the latest block,
// or it returns a dump of all instances in the form of a slice of StateChangeBodies.
message DebugResponse {
  repeated DebugResponseByzcoin byzcoins = 1;
  repeated DebugResponseState dump = 2;
}

// DebugResponseByzcoin represents one byzcoinid with the genesis and the latest block,
// as it is for debugging reasons, we trust the node and don't return any proof.
message DebugResponseByzcoin {
  required bytes byzcoinid = 1;
  optional skipchain.SkipBlock genesis = 2;
  optional skipchain.SkipBlock latest = 3;
}

// DebugResponseState holds one key/state pair of the response.
message DebugResponseState {
  required bytes key = 1;
  required StateChangeBody state = 2;
}

// DebugRemoveRequest asks the conode to delete the given byzcoin-instance from its database.
// It needs to be signed by the private key of the conode.
message DebugRemoveRequest {
  required bytes byzcoinid = 1;
  required bytes signature = 2;
}

// IDVersion holds the InstanceID and the latest known version of an instance.
message IDVersion {
  required bytes id = 1;
  required uint64 version = 2;
}

// GetUpdatesRequest allows to request changes to existing instances by
// sending a slice of known versions.
message GetUpdatesRequest {
  repeated IDVersion instances = 1;
  required uint64 flags = 2;
  required bytes latestblockid = 3;
}

// GetUpdatesReply only sends back the instances that have a new version,
// but will not send any proof for an instance that didn't change.
message GetUpdatesReply {
  repeated trie.Proof proofs = 1;
  repeated skipchain.ForwardLink links = 2;
  optional skipchain.SkipBlock latest = 3;
}
